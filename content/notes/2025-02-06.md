+++
title = "2025 02 06"
date = "2025-02-06T12:23:20-05:00"
draft = true

#
# description is optional
#
# description = "An optional description for SEO. If not provided, an automatically created summary will be used."
+++

- Started building a latent factor model in Stan that creates an index to predict the value of `1...N` trends on each of `1...T` days, where data is measured infrequently across time. Latent factor model will handle loadings and correlations across indicators to avoid over-indexing on all certain variables. We can extract the factor loadings and rescale them to present them as weights (that is [not exactly what they are](http://www.hawaii.edu/powerkills/UFA.HTM).)

stan code for this:

```
// File: dynamic_factor_model_missing.stan
data {
  int<lower=1> T;                  // Number of time points.
  int<lower=1> N;                  // Number of economic variables.
  int<lower=0> N_obs;              // Number of observed data points.
  int<lower=1, upper=T> t_obs[N_obs];  // Time index for each observed data point.
  int<lower=1, upper=N> i_obs[N_obs];  // Variable index for each observed data point.
  vector[N_obs] y_obs;             // Observed data for these indices.
}

parameters {
  vector[T] f;                     // Latent factor (the index) for each time point.
  vector[N] mu;                    // Intercepts for each variable.
  vector[N] lambda;                // Loadings for each variable.
  real<lower=0> sigma_y;           // Measurement error standard deviation.
  real<lower=0> sigma_f;           // State noise standard deviation for f.
  real<lower=-1, upper=1> rho;     // AR(1) coefficient for f.
}

model {
  // Priors
  mu ~ normal(0, 5);
  lambda ~ normal(0, 1);
  sigma_y ~ cauchy(0, 2.5);
  sigma_f ~ cauchy(0, 2.5);
  rho ~ uniform(-1, 1);

  // Latent factor evolution: vectorized AR(1) specification.
  f[1] ~ normal(0, sigma_f);
  f[2:T] ~ normal(rho * f[1:(T-1)], sigma_f);

  // Observation model: Vectorize by computing the predicted value for each observation.
  // Note: mu[i_obs] and lambda[i_obs] index the vectors mu and lambda with the observed variable indices.
  vector[N_obs] y_hat;
  y_hat = mu[i_obs] + elt_multiply(lambda[i_obs], f[t_obs]);
  y_obs ~ normal(y_hat, sigma_y);
}
```

and the r code would look something like:

```
# Suppose y_data is a T x N matrix (with some NA values)
T = nrow(y_data)
N = ncol(y_data)
# Find the indices of non-missing values.
obs_idx = which(!is.na(y_data), arr.ind = TRUE)
N_obs = nrow(obs_idx)
# Note: In R, arr.ind returns a matrix with columns "row" and "col".
t_obs = obs_idx[, "row"]
i_obs = obs_idx[, "col"]
y_obs = y_data[!is.na(y_data)]

# Bundle data for Stan:
stan_data = list(
  T = T,
  N = N,
  N_obs = N_obs,
  t_obs = t_obs,
  i_obs = i_obs,
  y_obs = y_obs
)

# Then compile and sample using rstan as usual:
library(cmdstanr)
stan_model = model(file = "dynamic_factor_model_missing.stan")
fit = model$sample(stan_model, data = stan_data, iter = 2000, chains = 4)
print(fit)
```